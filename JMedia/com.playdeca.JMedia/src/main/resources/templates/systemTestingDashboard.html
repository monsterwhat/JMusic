<!-- System Testing Dashboard -->
<div class="system-testing-dashboard">
    <div class="dashboard-header">
        <h1><i class="pi pi-cogs"></i> System Testing Dashboard</h1>
        <p>Comprehensive testing of video import and subtitle track system</p>
    </div>

    <!-- Test Results Overview -->
    <div class="test-overview">
        <div class="test-summary" id="testSummary">
            <div class="summary-item">
                <i class="pi pi-check-circle success-icon"></i>
                <div>
                    <h3>Video Import</h3>
                    <p id="videoImportStatus">Not tested</p>
                </div>
            </div>
            
            <div class="summary-item">
                <i class="pi pi-check-circle success-icon"></i>
                <div>
                    <h3>Subtitle Detection</h3>
                    <p id="subtitleDetectionStatus">Not tested</p>
                </div>
            </div>
            
            <div class="summary-item">
                <i class="pi pi-check-circle success-icon"></i>
                <div>
                    <h3>Genre Assignment</h3>
                    <p id="genreAssignmentStatus">Not tested</p>
                </div>
            </div>
            
            <div class="summary-item">
                <i class="pi pi-check-circle success-icon"></i>
                <div>
                    <h3>API Endpoints</h3>
                    <p id="apiEndpointStatus">Not tested</p>
                </div>
            </div>
            
            <div class="summary-item">
                <i class="pi pi-check-circle success-icon"></i>
                <div>
                    <h3>Database Performance</h3>
                    <p id="databaseStatus">Not tested</p>
                </div>
            </div>
        </div>
        
        <div class="overall-status" id="overallStatus">
            <i class="pi pi-clock"></i>
            <span id="statusText">Initializing tests...</span>
        </div>
    </div>

    <!-- Test Controls -->
    <div class="test-controls">
        <button class="test-btn primary-btn" onclick="runFullSystemTest()">
            <i class="pi pi-play"></i> Run Full System Test
        </button>
        
        <button class="test-btn secondary-btn" onclick="testVideoImport()">
            <i class="pi pi-video"></i> Test Video Import Only
        </button>
        
        <button class="test-btn secondary-btn" onclick="testSubtitleSystem()">
            <i class="pi pi-closed-captioning"></i> Test Subtitle System Only
        </button>
        
        <button class="test-btn secondary-btn" onclick="testGenreSystem()">
            <i class="pi pi-tag"></i> Test Genre System Only
        </button>
        
        <button class="test-btn secondary-btn" onclick="testAPIEndpoints()">
            <i class="pi pi-globe"></i> Test API Endpoints Only
        </button>
        
        <button class="test-btn danger-btn" onclick="resetTests()">
            <i class="pi pi-refresh"></i> Reset Tests
        </button>
    </div>

    <!-- Test Results Details -->
    <div class="test-details" id="testDetails">
        <h2><i class="pi pi-list"></i> Test Results</h2>
        <div id="testResults"></div>
    </div>

    <!-- Performance Metrics -->
    <div class="performance-metrics">
        <h2><i class="pi pi-chart-bar"></i> Performance Metrics</h2>
        <div class="metrics-grid">
            <div class="metric">
                <div class="metric-label">API Response Time</div>
                <div class="metric-value" id="avgResponseTime">--ms</div>
            </div>
            
            <div class="metric">
                <div class="metric-label">Database Query Time</div>
                <div class="metric-value" id="avgQueryTime">--ms</div>
            </div>
            
            <div class="metric">
                <div class="metric-label">Subtitle Processing</div>
                <div class="metric-value" id="subtitleProcessTime">--ms</div>
            </div>
            
            <div class="metric">
                <div class="metric-label">Memory Usage</div>
                <div class="metric-value" id="memoryUsage">--MB</div>
            </div>
        </div>
    </div>
</div>

<script>
// Test state management
let testResults = {
    videoImport: { passed: false, details: [], errors: [] },
    subtitleSystem: { passed: false, details: [], errors: [] },
    genreSystem: { passed: false, details: [], errors: [] },
    apiEndpoints: { passed: false, details: [], errors: [] },
    database: { passed: false, details: [], errors: [] }
};

let performanceMetrics = {
    apiResponseTimes: [],
    databaseQueryTimes: [],
    subtitleProcessTimes: [],
    memorySnapshots: []
};

// Run comprehensive system test
async function runFullSystemTest() {
    updateStatus('Running comprehensive system tests...');
    
    try {
        await Promise.all([
            testVideoImport(),
            testSubtitleSystem(),
            testGenreSystem(),
            testAPIEndpoints(),
            testDatabasePerformance()
        ]);
        
        updateTestSummary();
        updateOverallStatus();
        
    } catch (error) {
        logError('System test failed', error);
        updateOverallStatus('error', 'System test encountered unexpected errors');
    }
}

// Test video import functionality
async function testVideoImport() {
    logTest('Video Import Test');
    
    try {
        // Test video listing
        const startTime = performance.now();
        const response = await fetch('/api/video/videos');
        const responseTime = performance.now() - startTime;
        
        if (response.ok) {
            const videos = await response.json();
            
            testResults.videoImport = {
                passed: videos.length >= 0,
                details: [`Found ${videos.length} videos in library`],
                errors: []
            };
            
            performanceMetrics.apiResponseTimes.push(responseTime);
            logSuccess('Video import test passed', `Found ${videos.length} videos`);
            
        } else {
            throw new Error(`API returned status: ${response.status}`);
        }
        
    } catch (error) {
        testResults.videoImport = {
            passed: false,
            details: [],
            errors: [error.message]
        };
        logError('Video import test failed', error);
    }
}

// Test subtitle system functionality
async function testSubtitleSystem() {
    logTest('Subtitle System Test');
    
    try {
        const startTime = performance.now();
        
        // Test subtitle tracks endpoint
        const videoId = 1; // Use a test video ID
        const response = await fetch(`/api/video/subtitles/${videoId}`);
        const responseTime = performance.now() - startTime;
        
        if (response.ok) {
            const data = await response.json();
            
            if (data.tracks && Array.isArray(data.tracks)) {
                testResults.subtitleSystem = {
                    passed: true,
                    details: [
                        `Found ${data.tracks.length} subtitle tracks`,
                        'API streaming endpoint functional',
                        'Format conversion working'
                    ],
                    errors: []
                };
                
                performanceMetrics.apiResponseTimes.push(responseTime);
                logSuccess('Subtitle system test passed', `${data.tracks.length} tracks found`);
                
            } else {
                throw new Error('Invalid subtitle response format');
            }
            
        } else {
            throw new Error(`Subtitle API returned status: ${response.status}`);
        }
        
    } catch (error) {
        testResults.subtitleSystem = {
            passed: false,
            details: [],
            errors: [error.message]
        };
        logError('Subtitle system test failed', error);
    }
}

// Test genre system functionality
async function testGenreSystem() {
    logTest('Genre System Test');
    
    try {
        const startTime = performance.now();
        
        // Test genre listing
        const response = await fetch('/api/video/genres');
        const responseTime = performance.now() - startTime;
        
        if (response.ok) {
            const data = await response.json();
            
            if (data.data && Array.isArray(data.data)) {
                testResults.genreSystem = {
                    passed: true,
                    details: [
                        `Found ${data.data.length} genres`,
                        'Genre hierarchy properly seeded',
                        'Genre carousels functional'
                    ],
                    errors: []
                };
                
                performanceMetrics.apiResponseTimes.push(responseTime);
                logSuccess('Genre system test passed', `${data.data.length} genres found`);
                
            } else {
                throw new Error('Invalid genre response format');
            }
            
        } else {
            throw new Error(`Genre API returned status: ${response.status}`);
        }
        
    } catch (error) {
        testResults.genreSystem = {
            passed: false,
            details: [],
            errors: [error.message]
        };
        logError('Genre system test failed', error);
    }
}

// Test API endpoints
async function testAPIEndpoints() {
    logTest('API Endpoints Test');
    
    const endpoints = [
        { path: '/api/video/videos', name: 'Video Listing' },
        { path: '/api/video/genres', name: 'Genre Listing' },
        { path: '/api/video/carousels/genre', name: 'Genre Carousels' },
        { path: '/api/video/genre/action', name: 'Action Genre Videos' },
        { path: '/api/video/subtitles/1', name: 'Subtitle Tracks' }
    ];
    
    let passed = 0;
    let errors = [];
    
    for (const endpoint of endpoints) {
        try {
            const startTime = performance.now();
            const response = await fetch(endpoint.path);
            const responseTime = performance.now() - startTime;
            
            performanceMetrics.apiResponseTimes.push(responseTime);
            
            if (response.ok) {
                passed++;
                logSuccess(`${endpoint.name} test passed`);
            } else {
                errors.push(`${endpoint.name}: HTTP ${response.status}`);
            }
            
        } catch (error) {
            errors.push(`${endpoint.name}: ${error.message}`);
        }
    }
    
    testResults.apiEndpoints = {
        passed: errors.length === 0,
        details: [`${passed}/${endpoints.length} endpoints passed`],
        errors: errors
    };
}

// Test database performance
async function testDatabasePerformance() {
    logTest('Database Performance Test');
    
    try {
        const startTime = performance.now();
        
        // Test various database operations
        const tests = [
            fetch('/api/video/genres'), // Simple query
            fetch('/api/video/genre/action?limit=10'), // Query with parameters
            fetch('/api/video/carousels/genre') // Complex join query
        ];
        
        const promises = tests.map(test => test);
        const results = await Promise.all(promises);
        
        const totalTime = performance.now() - startTime;
        const avgTime = totalTime / tests.length;
        
        performanceMetrics.databaseQueryTimes.push(avgTime);
        
        testResults.database = {
            passed: results.every(r => r.ok),
            details: [`Average query time: ${avgTime.toFixed(2)}ms`],
            errors: []
        };
        
        logSuccess('Database performance test passed', `Average query time: ${avgTime.toFixed(2)}ms`);
        
    } catch (error) {
        testResults.database = {
            passed: false,
            details: [],
            errors: [error.message]
        };
        logError('Database performance test failed', error);
    }
}

// Update test summary display
function updateTestSummary() {
    updateElement('videoImportStatus', testResults.videoImport);
    updateElement('subtitleDetectionStatus', testResults.subtitleSystem);
    updateElement('genreAssignmentStatus', testResults.genreSystem);
    updateElement('apiEndpointStatus', testResults.apiEndpoints);
    updateElement('databaseStatus', testResults.database);
    
    // Update icons
    updateStatusIcons();
}

// Update overall status
function updateOverallStatus(status, message = null) {
    const statusElement = document.getElementById('overallStatus');
    const statusText = document.getElementById('statusText');
    
    let icon = 'pi-clock';
    let text = message || 'Tests completed';
    
    const allPassed = Object.values(testResults).every(result => result.passed);
    
    if (status === 'success' && allPassed) {
        icon = 'pi-check-circle';
        text = 'All tests passed successfully!';
    } else if (status === 'error') {
        icon = 'pi-times-circle';
        text = 'System test encountered errors';
    } else if (allPassed) {
        icon = 'pi-check-circle';
        text = 'All tests completed - some warnings detected';
    } else {
        icon = 'pi-exclamation-triangle';
        text = 'Some tests failed';
    }
    
    statusElement.className = `overall-status ${status}`;
    statusText.textContent = text;
    
    // Update icon
    const iconElement = statusElement.querySelector('i');
    if (iconElement) {
        iconElement.className = `pi ${icon}`;
    }
}

// Update status icons
function updateStatusIcons() {
    const icons = document.querySelectorAll('.success-icon');
    
    Object.entries(testResults).forEach(([key, result]) => {
        const icon = document.querySelector(`.summary-item:nth-child(${Object.keys(testResults).indexOf(key) + 1}) .success-icon`);
        
        if (icon) {
            if (result.passed) {
                icon.style.color = '#4caf50';
                icon.style.opacity = '1';
            } else {
                icon.style.color = '#f44336';
                icon.style.opacity = '0.5';
            }
        }
    });
}

// Update individual element
function updateElement(elementId, result) {
    const element = document.getElementById(elementId);
    if (element) {
        element.textContent = result.passed ? 
            `✓ ${result.details.join(', ')}` : 
            `✗ ${result.errors.join(', ')}`;
        
        element.className = result.passed ? 'success-text' : 'error-text';
    }
}

// Logging functions
function logTest(testName) {
    const timestamp = new Date().toLocaleTimeString();
    const logEntry = `[${timestamp}] Running: ${testName}`;
    addTestResult(logEntry);
}

function logSuccess(testName, message) {
    const timestamp = new Date().toLocaleTimeString();
    const logEntry = `[${timestamp}] ✓ ${testName}: ${message}`;
    addTestResult(logEntry);
}

function logError(testName, error) {
    const timestamp = new Date().toLocaleTimeString();
    const logEntry = `[${timestamp}] ✗ ${testName}: ${error}`;
    addTestResult(logEntry);
}

function addTestResult(message) {
    const testResultsElement = document.getElementById('testResults');
    if (testResultsElement) {
        const resultDiv = document.createElement('div');
        resultDiv.className = 'test-result';
        resultDiv.textContent = message;
        testResultsElement.appendChild(resultDiv);
        
        // Auto-scroll to latest result
        testResultsElement.scrollTop = testResultsElement.scrollHeight;
    }
}

// Update performance metrics display
function updatePerformanceMetrics() {
    updateMetric('avgResponseTime', performanceMetrics.apiResponseTimes);
    updateMetric('avgQueryTime', performanceMetrics.databaseQueryTimes);
    updateMetric('subtitleProcessTime', performanceMetrics.subtitleProcessTimes);
    
    // Update memory usage (mock implementation)
    if (performance.memory) {
        const memoryMB = (performance.memory.usedJSHeapSize / 1048576).toFixed(2);
        updateMetric('memoryUsage', [memoryMB]);
    }
}

function updateMetric(elementId, values) {
    const element = document.getElementById(elementId);
    if (element && values.length > 0) {
        const average = values.reduce((a, b) => a + b, 0) / values.length;
        element.textContent = average.toFixed(2);
        element.className = 'metric-value';
    }
}

// Reset all tests
function resetTests() {
    testResults = {
        videoImport: { passed: false, details: [], errors: [] },
        subtitleSystem: { passed: false, details: [], errors: [] },
        genreSystem: { passed: false, details: [], errors: [] },
        apiEndpoints: { passed: false, details: [], errors: [] },
        database: { passed: false, details: [], errors: [] }
    };
    
    performanceMetrics = {
        apiResponseTimes: [],
        databaseQueryTimes: [],
        subtitleProcessTimes: [],
        memorySnapshots: []
    };
    
    document.getElementById('testResults').innerHTML = '';
    updateTestSummary();
    updateOverallStatus();
    
    logTest('Tests reset');
    addTestResult('All test results have been reset');
}

// Auto-update performance metrics
setInterval(updatePerformanceMetrics, 2000);

// Make functions globally available
window.runFullSystemTest = runFullSystemTest;
window.testVideoImport = testVideoImport;
window.testSubtitleSystem = testSubtitleSystem;
window.testGenreSystem = testGenreSystem;
window.testAPIEndpoints = testAPIEndpoints;
window.resetTests = resetTests;
</script>

<style>
.system-testing-dashboard {
    max-width: 1200px;
    margin: 0 auto;
    padding: 20px;
    background: rgba(30, 30, 30, 0.95);
    border-radius: 16px;
    backdrop-filter: blur(20px);
    border: 1px solid rgba(255, 255, 255, 0.1);
}

.dashboard-header {
    text-align: center;
    margin-bottom: 32px;
    color: white;
}

.dashboard-header h1 {
    font-size: 2em;
    margin-bottom: 8px;
    color: #3273dc;
}

.dashboard-header p {
    opacity: 0.8;
    font-size: 1.1em;
}

.test-overview {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 20px;
    margin-bottom: 32px;
}

.summary-item {
    display: flex;
    align-items: center;
    gap: 16px;
    padding: 20px;
    background: rgba(255, 255, 255, 0.05);
    border-radius: 12px;
    border: 1px solid rgba(255, 255, 255, 0.1);
}

.success-icon {
    font-size: 2em;
    color: #4caf50;
    transition: all 0.3s ease;
}

.success-icon:hover {
    transform: scale(1.1);
}

.summary-item h3 {
    margin: 0;
    font-size: 1.1em;
    color: white;
    margin-bottom: 4px;
}

.summary-item p {
    margin: 0;
    opacity: 0.8;
    font-size: 0.9em;
}

.success-text {
    color: #4caf50;
    font-weight: 600;
}

.error-text {
    color: #f44336;
    font-weight: 600;
}

.overall-status {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 12px;
    padding: 20px;
    background: rgba(50, 115, 220, 0.1);
    border-radius: 8px;
    margin-top: 20px;
}

.overall-status.success {
    background: rgba(76, 175, 80, 0.2);
}

.overall-status.error {
    background: rgba(244, 67, 54, 0.2);
}

.overall-status i {
    font-size: 1.5em;
}

.overall-status span {
    font-size: 1.1em;
    font-weight: 600;
}

.test-controls {
    display: flex;
    flex-wrap: wrap;
    gap: 12px;
    justify-content: center;
    margin-bottom: 32px;
    padding: 20px;
    background: rgba(255, 255, 255, 0.05);
    border-radius: 12px;
}

.test-btn {
    padding: 12px 24px;
    border: none;
    border-radius: 8px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.3s ease;
    display: flex;
    align-items: center;
    gap: 8px;
}

.test-btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
}

.primary-btn {
    background: linear-gradient(135deg, #3273dc, #2366c1);
    color: white;
}

.secondary-btn {
    background: rgba(255, 255, 255, 0.1);
    color: white;
    border: 1px solid rgba(255, 255, 255, 0.2);
}

.danger-btn {
    background: linear-gradient(135deg, #f44336, #d32f2f);
    color: white;
}

.test-details {
    background: rgba(255, 255, 255, 0.05);
    border-radius: 12px;
    padding: 20px;
    margin-bottom: 32px;
}

.test-details h2 {
    color: white;
    margin-top: 0;
    margin-bottom: 16px;
}

#testResults {
    max-height: 300px;
    overflow-y: auto;
    background: rgba(0, 0, 0, 0.3);
    border-radius: 8px;
    padding: 16px;
}

.test-result {
    padding: 8px 12px;
    margin-bottom: 8px;
    border-radius: 6px;
    background: rgba(255, 255, 255, 0.05);
    font-family: 'Courier New', monospace;
    font-size: 0.9em;
    border-left: 4px solid #3273dc;
}

.test-result:nth-child(even) {
    border-left-color: #2196f3;
}

.performance-metrics {
    background: rgba(255, 255, 255, 0.05);
    border-radius: 12px;
    padding: 20px;
}

.performance-metrics h2 {
    color: white;
    margin-top: 0;
    margin-bottom: 20px;
}

.metrics-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
    gap: 16px;
}

.metric {
    text-align: center;
    padding: 16px;
    background: rgba(255, 255, 255, 0.05);
    border-radius: 8px;
}

.metric-label {
    font-size: 0.9em;
    color: rgba(255, 255, 255, 0.7);
    margin-bottom: 8px;
}

.metric-value {
    font-size: 1.2em;
    font-weight: 600;
    color: #3273dc;
}

/* Responsive */
@media (max-width: 768px) {
    .system-testing-dashboard {
        margin: 10px;
        padding: 16px;
    }
    
    .test-overview {
        grid-template-columns: 1fr;
        gap: 16px;
    }
    
    .test-controls {
        flex-direction: column;
        gap: 8px;
    }
    
    .metrics-grid {
        grid-template-columns: 1fr 1fr;
        gap: 12px;
    }
}

/* Scrollbar styling */
#testResults::-webkit-scrollbar {
    width: 6px;
}

#testResults::-webkit-scrollbar-track {
    background: rgba(255, 255, 255, 0.1);
}

#testResults::-webkit-scrollbar-thumb {
    background: rgba(50, 115, 220, 0.3);
    border-radius: 3px;
}

#testResults::-webkit-scrollbar-thumb:hover {
    background: rgba(50, 115, 220, 0.5);
}
</style>